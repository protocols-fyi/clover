# Explain like I'm five

I'll try to assume very little knowledge!

### OpenAPIs

First, let's talk about APIs. APIs help machines/servers communicate.

![](/eli5/0_apis.png)

The most common API conventions are REST or GraphQL. They both work over HTTP. GraphQL is nice because it is a strongly typed schema with its own query language. Meanwhile REST does not enforce any schema conventions.

If you want to add schema validation to your REST API, you can make it OpenAPI compliant. OpenAPI is a specification for describing REST APIs. It is a JSON schema that describes the structure of your API. An OpenAPI schema can help other humans and machines understand how your API works. They can generate client code against your API, or generate test cases, or configure infrastructure, etc.

For example, [OpenAI's ChatGPT plugin system](https://platform.openai.com/docs/plugins/introduction) relies on OpenAPIs. A "ChatGPT plugin" is just a pointer to an OpenAPI specification. Then ChatGPT will figure out how to use it from that specification alone üôÄ

![](/eli5/1_openapi.png)

### Client generation

If an API is OpenAPI compliant, you can generate client-code against it. This is a huge time-saver. You don't have to manually write the HTTP requests and responses. You can just import the client and call the functions. The client is type-safe, so you can't make typos in the API calls.

Here is an example of querying against an API which isn't OpenAPI compliant.

```ts
// someone else's API endpoint, available on
// https://example.com/api

const handler = (request: Request) => {
  const name = new URL(request.url).searchParams.get("name");
  return new Response(JSON.stringify({ greeting: `Hello, ${name}!` }), {
    headers: { "content-type": "application/json" },
  });
};

// how you would query against it in your code

const response = await fetch(
  `https://example.com/api?name=${encodeURIComponent("Hedwig")}`
);
const data: {
  greeting: string;
} = await response.json();
```

This feels a bit brittle. You have to make sure you are passing the right query params, and that the response is what you expect. If you make a typo, you won't know until runtime.

Here is an example of querying against an API which is OpenAPI compliant.

```json
// https://petstore3.swagger.io/api/v3/openapi.json
{
  "openapi": "3.0.2",
  "info": {
    "title": "Petstore - OpenAPI 3.0",
    "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.",
    "version": "1.0.17"
  },
  "servers": [
    {
      "url": "/api/v3"
    }
  ],
  "tags": [
    {
      "name": "pet",
      "description": "Everything about your Pets"
    }
  ],
  "paths": {
    "/pet/findByStatus": {
      "get": {
        "tags": ["pet"],
        "summary": "Finds Pets by status",
        "description": "Multiple status values can be provided with comma separated strings",
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "Status values that need to be considered for filter",
            "required": false,
            "explode": true,
            "schema": {
              "type": "string",
              "default": "available",
              "enum": ["available", "pending", "sold"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pet"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

We can generate a type-safe client against it using a library like [Orval](https://orval.dev/overview) or [oazapfts](https://github.com/oazapfts/oazapfts). These libraries wrap `fetch`/`axios` and do the input/output parsing in the native typesystem of the language, e.g. TypeScript, Go, Rust etc. Some pseudocode:

```bash
codegen --input https://example.com/openapi-spec.json --output ./src/client.ts
```

And now we can use the client in our code. Notice how it is type-safe, and we don't have to worry about typos, nor about how to prepare the underlying `fetch` call.

```ts
import { findPetsByStatus } from "./src/client";

// find pet by status
const response = await findPetsByStatus({
  status: ["available", "pending"],
});
```

## Motivation

### How modern web frameworks handle "backend"

Traditionally, frameworks like Next.js have let you write server code inside page lifecycle hooks like `getServerSideProps`, where data could be plumbed through once on page-load. Or you could write server code inside dedicated API routes, and the client would have to fetch data from the API route. The separation between client and server was clearer, even though it is a hassle to pass data back and forth in a type-safe and ergonomic way.

```ts
// server code in the express style
// e.g. https://nextjs.org/docs/pages/building-your-application/routing/api-routes
const handler = (req, res) => {
  return res.json({});
};

// OR in the winterCG style
// e.g. https://nextjs.org/docs/app/building-your-application/routing/router-handlers
const handler = (request: Request) => {
  return new Response();
};

// OR in dedicated lifecycle hooks
// e.g. https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props
export const getServerSideProps = () => {
  return {
    props: {},
  };
};

// OR inside loaders
// e.g. https://remix.run/docs/en/main/route/loader
export const loader = async () => {
  return json({ ok: true });
};
```

Requesting data from the client is typically done with `fetch` or `axios` or some other HTTP client. There is no type-safety between the client and server. You have to manually specify the types.

```tsx
const MyComponent = () => {
  const [data, setData] = useState();

  const requestData = async () => {
    const response = await fetch("/api/my-data");
    const data = await response.json();
    setData(data);
  };

  useEffect(() => {
    requestData();
  }, []);
};
```

### Third-party libraries

Libraries like TRPC, Zodios etc. have improved the developer experience a lot. They all follow a similar pattern where they wrap over the backend API route, and provide a client for the frontend to consume. The client is inferred from the server code, so the client and server are always in sync. The client is type-safe, so you can't make typos in the API calls. But these frameworks can sometimes involve a decent amount of boilerplate (although far less that what you would have to do yourself to get the same level of functionality).

Here is a video from TRPC that illustrates this concept:

<video autoplay muted>
  <source
    src="https://assets.trpc.io/www/v10/v10-dark-landscape.mp4"
    type="video/mp4"
  />
</video>

And here is Zodios:

<video autoplay muted>
  <source src="https://www.zodios.org/video/zodios.mp4" type="video/mp4" />
</video>

Clover also does something similar, although it is on a per-route basis. We'll discuss how Clover works in a bit.

#### Side note on type-safety

Just having TypeScript types doesn't gurarantee type-safety over the wire during runtime. What if there was a cosmic bitflip ‚òÄÔ∏èüíÄ when the data was enroute from the server to the client? To gurarantee type-safety, it's generally a good idea to use a schema validation library like Zod, which is what you see with all the `z.object` stuff in the video screenshots above. You can learn more about Zod at https://github.com/colinhacks/zod.

```ts
// an example from Zod's documentation

import { z } from "zod";

// the schema
const User = z.object({
  username: z.string(),
});

// the type guarantee
type User = z.infer<typeof User>;
// { username: string }

// the runtime guarantee
User.parse({ username: "Ludwig" });
```

### Blurring client-server boundaries

Frameworks are adding their own blurring of the client-server boundary. Remix and Next.js both offer ways to colocate server code with client code and disambiguate them with special named exports or special directives e.g. `use-server`. Each piece of server logic is either spun up on a transient Lambda function, or a long-running server process. The client can just directly import and call the server function, and an RPC (remote procedure call) is coordinated in the background üôÄ There is a lot of magic behind the scenes.

### Why Clover

As frameworks like Next.js introduce their own first-party functionality to fetch and mutate data, I expect that the use-case for external libraries like TRPC, Zodios etc. will be diminished in the coming years. But occasionally there is still a need for exposing some data from your server via a well-documented public API. There isn't much support for this in the modern frameworks. So, Clover is a small library that aims to fill that gap.
